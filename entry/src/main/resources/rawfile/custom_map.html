<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>自定义地图</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f7f5f2;
      font-family: "PingFang SC", "HarmonyOS Sans", "Microsoft YaHei", sans-serif;
    }
    #map {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    .badge {
      position: absolute;
      left: 50%;
      top: 16px;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.88);
      color: #27324a;
      padding: 8px 14px;
      border-radius: 18px;
      font-size: 13px;
      letter-spacing: 0.4px;
      box-shadow: 0 6px 16px rgba(27, 38, 56, 0.12);
      pointer-events: none;
    }
    .controls {
      position: absolute;
      right: 16px;
      bottom: 24px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
    }
    .control-btn {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.92);
      color: #2b3347;
      font-size: 20px;
      font-weight: 600;
      box-shadow: 0 8px 18px rgba(22, 34, 51, 0.18);
      cursor: pointer;
    }
    .control-btn:active {
      transform: scale(0.96);
    }
    .theme-toggle {
      font-size: 12px;
      padding: 0 8px;
      width: 72px;
      height: 36px;
      border-radius: 18px;
    }
  </style>
</head>
<body>
  <canvas id="map"></canvas>
  <div class="badge">自定义地图 · 支持拖动与双指缩放</div>
  <div class="controls">
    <button class="control-btn" id="zoomIn">+</button>
    <button class="control-btn" id="zoomOut">−</button>
    <button class="control-btn theme-toggle" id="themeToggle">日间</button>
  </div>

  <script>
    const canvas = document.getElementById('map');
    const ctx = canvas.getContext('2d');
    const badge = document.querySelector('.badge');
    const zoomInButton = document.getElementById('zoomIn');
    const zoomOutButton = document.getElementById('zoomOut');
    const themeToggle = document.getElementById('themeToggle');
    const THEMES = {
      day: {
        background: '#f7f5f2',
        water: '#b9d9f5',
        park: '#cfe8c6',
        pitchFill: '#8fd9c2',
        pitchAccent: '#f1b27a',
        buildingFill: '#efe8dd',
        buildingStroke: '#d7cbbf',
        mapBase: '#f7f5f2',
        label: '#263042',
        labelHalo: 'rgba(255, 255, 255, 0.92)',
        poi: '#2f7df6',
        road: {
          motorway: { width: 5.2, color: '#f5c48b', casing: '#d9b07a' },
          trunk: { width: 4.8, color: '#f3d6a4', casing: '#d2b489' },
          primary: { width: 4.4, color: '#f4e0bd', casing: '#d7c8a7' },
          secondary: { width: 3.6, color: '#ffffff', casing: '#d7cbbf' },
          tertiary: { width: 3.1, color: '#ffffff', casing: '#d7cbbf' },
          residential: { width: 2.6, color: '#ffffff', casing: '#dcd3c7' },
          service: { width: 2.1, color: '#ffffff', casing: '#e4ddd3' },
          footway: { width: 1.5, color: '#f1f7ee', casing: '#b9d3b0' },
          path: { width: 1.2, color: '#f1f7ee', casing: '#b9d3b0' }
        }
      },
      night: {
        background: '#1d2230',
        water: '#27435e',
        park: '#1e3a2f',
        pitchFill: '#1f5a4d',
        pitchAccent: '#c58a5e',
        buildingFill: '#2b3246',
        buildingStroke: '#404a62',
        mapBase: '#1d2230',
        label: '#e5ecff',
        labelHalo: 'rgba(20, 24, 33, 0.85)',
        poi: '#6ea8ff',
        road: {
          motorway: { width: 5.2, color: '#c18b4b', casing: '#7d5c35' },
          trunk: { width: 4.8, color: '#b69063', casing: '#6e5639' },
          primary: { width: 4.4, color: '#a98257', casing: '#66503a' },
          secondary: { width: 3.6, color: '#6e7488', casing: '#4b5164' },
          tertiary: { width: 3.1, color: '#6e7488', casing: '#4b5164' },
          residential: { width: 2.6, color: '#717991', casing: '#4b5164' },
          service: { width: 2.1, color: '#717991', casing: '#4b5164' },
          footway: { width: 1.5, color: '#5a6b61', casing: '#3f5147' },
          path: { width: 1.2, color: '#5a6b61', casing: '#3f5147' }
        }
      }
    };
    let currentTheme = 'day';

    const state = {
  scale: 1,
  dpr: window.devicePixelRatio || 1,
      minScale: 0.5,
      maxScale: 5,
      offsetX: 0,
      offsetY: 0,
      dragging: false,
      lastX: 0,
      lastY: 0,
      pinchStartDist: 0,
      pinchStartScale: 1
    };

    const OSM_URLS = [
      'map.osm',
      './map.osm',
      'resource://rawfile/map.osm'
    ];
    const renderData = {
      bounds: null,
      roads: [],
      buildings: [],
      areas: [],
      waters: [],
      pitches: [],
      labels: []
    };
    const customMarkers = [];
    const graph = { nodes: new Map(), adj: new Map() };
    let routePolyline = [];
    let routeInfo = null;
    let showAutoLabels = true;
    let mapWidth = 2000;
    let mapHeight = 2000;
    let dataReady = false;
    let loadError = null;

    function resize() {
      state.dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * state.dpr;
      canvas.height = window.innerHeight * state.dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(state.dpr, state.dpr);
      if (dataReady) {
        fitToView();
      }
      draw();
    }

    function clampScale(scale) {
      return Math.min(state.maxScale, Math.max(state.minScale, scale));
    }

    function zoomAt(clientX, clientY, newScale) {
      const scale = state.scale;
      const worldX = (clientX - state.offsetX) / scale;
      const worldY = (clientY - state.offsetY) / scale;
      state.scale = clampScale(newScale);
      state.offsetX = clientX - worldX * state.scale;
      state.offsetY = clientY - worldY * state.scale;
    }

    function setBadge(text) {
      if (badge) {
        badge.textContent = text;
      }
    }

    function parseTags(element) {
      const tags = {};
      const tagNodes = element.getElementsByTagName('tag');
      for (const tag of tagNodes) {
        const key = tag.getAttribute('k');
        const value = tag.getAttribute('v');
        if (key && value) {
          tags[key] = value;
        }
      }
      return tags;
    }

    function parseBounds(xmlDoc) {
      const boundsEl = xmlDoc.querySelector('bounds');
      if (!boundsEl) {
        return null;
      }
      const minLat = Number(boundsEl.getAttribute('minlat'));
      const minLon = Number(boundsEl.getAttribute('minlon'));
      const maxLat = Number(boundsEl.getAttribute('maxlat'));
      const maxLon = Number(boundsEl.getAttribute('maxlon'));
      if ([minLat, minLon, maxLat, maxLon].some((value) => Number.isNaN(value))) {
        return null;
      }
      return { minLat, minLon, maxLat, maxLon };
    }

    function computeMapSize(bounds) {
      const lonSpan = bounds.maxLon - bounds.minLon;
      const latSpan = bounds.maxLat - bounds.minLat;
      mapWidth = 2000;
      if (!Number.isFinite(lonSpan) || !Number.isFinite(latSpan) || lonSpan <= 0 || latSpan <= 0) {
        mapHeight = 2000;
        return;
      }
      mapHeight = mapWidth * (latSpan / lonSpan);
      if (!Number.isFinite(mapHeight) || mapHeight <= 0) {
        mapHeight = 2000;
      }
    }

    function getCentroid(points) {
      let sumX = 0;
      let sumY = 0;
      for (const point of points) {
        sumX += point.x;
        sumY += point.y;
      }
      return {
        x: sumX / points.length,
        y: sumY / points.length
      };
    }

    function project(lat, lon) {
      const bounds = renderData.bounds;
      const lonSpan = bounds.maxLon - bounds.minLon;
      const latSpan = bounds.maxLat - bounds.minLat;
      if (!Number.isFinite(lonSpan) || !Number.isFinite(latSpan) || lonSpan <= 0 || latSpan <= 0) {
        return { x: 0, y: 0 };
      }
      const x = ((lon - bounds.minLon) / lonSpan) * mapWidth;
      const y = ((bounds.maxLat - lat) / latSpan) * mapHeight;
      return { x, y };
    }

    function addEdge(nodeIdA, nodeIdB, weight) {
      if (!graph.adj.has(nodeIdA)) {
        graph.adj.set(nodeIdA, []);
      }
      if (!graph.adj.has(nodeIdB)) {
        graph.adj.set(nodeIdB, []);
      }
      graph.adj.get(nodeIdA).push({ to: nodeIdB, w: weight });
      graph.adj.get(nodeIdB).push({ to: nodeIdA, w: weight });
    }

    function distanceMeters(lat1, lon1, lat2, lon2) {
      const dx = (lon2 - lon1) * 111320 * Math.cos(((lat1 + lat2) / 2) * Math.PI / 180);
      const dy = (lat2 - lat1) * 110540;
      return Math.hypot(dx, dy);
    }

    function buildRenderData(xmlDoc) {
      renderData.roads = [];
      renderData.buildings = [];
      renderData.areas = [];
      renderData.waters = [];
  renderData.pitches = [];
      renderData.labels = [];
      graph.nodes = new Map();
      graph.adj = new Map();

      const nodes = new Map();
      const nodeElements = xmlDoc.getElementsByTagName('node');
      for (const node of nodeElements) {
        const id = node.getAttribute('id');
        const lat = Number(node.getAttribute('lat'));
        const lon = Number(node.getAttribute('lon'));
        if (!id || Number.isNaN(lat) || Number.isNaN(lon)) {
          continue;
        }
        const tags = parseTags(node);
        nodes.set(id, { lat, lon, tags });
        graph.nodes.set(id, { lat, lon });

        const name = tags.name;
        const isLabel = Boolean(name && (tags.amenity || tags.shop || tags.tourism || tags.barrier || tags.man_made || tags.building));
        if (isLabel) {
          renderData.labels.push({
            name,
            position: project(lat, lon),
            priority: tags.amenity || tags.shop || tags.tourism ? 3 : 2
          });
        }
      }

      const wayElements = xmlDoc.getElementsByTagName('way');
      for (const way of wayElements) {
        const tags = parseTags(way);
        const nodeRefs = way.getElementsByTagName('nd');
        const points = [];
        for (const ref of nodeRefs) {
          const nodeId = ref.getAttribute('ref');
          const node = nodeId ? nodes.get(nodeId) : null;
          if (!node) {
            continue;
          }
          points.push(project(node.lat, node.lon));
        }
        if (points.length < 2) {
          continue;
        }

        if (tags.building) {
          renderData.buildings.push({ points, name: tags.name || '' });
          if (tags.name) {
            renderData.labels.push({
              name: tags.name,
              position: getCentroid(points),
              priority: 2
            });
          }
          continue;
        }

        if (tags.leisure === 'pitch' || tags.sport) {
          renderData.pitches.push({ points, sport: tags.sport || '' });
          if (tags.name) {
            renderData.labels.push({
              name: tags.name,
              position: getCentroid(points),
              priority: 2
            });
          }
          continue;
        }

        if (tags.highway) {
          renderData.roads.push({ points, type: tags.highway, name: tags.name || '' });
          if (tags.name) {
            renderData.labels.push({
              name: tags.name,
              position: getCentroid(points),
              priority: 1
            });
          }
          for (let i = 1; i < nodeRefs.length; i++) {
            const prevId = nodeRefs[i - 1].getAttribute('ref');
            const currId = nodeRefs[i].getAttribute('ref');
            const prevNode = prevId ? nodes.get(prevId) : null;
            const currNode = currId ? nodes.get(currId) : null;
            if (!prevNode || !currNode) {
              continue;
            }
            const w = distanceMeters(prevNode.lat, prevNode.lon, currNode.lat, currNode.lon);
            addEdge(prevId, currId, w);
          }
          continue;
        }

        if (tags.natural === 'water' || tags.landuse === 'reservoir' || tags.waterway) {
          renderData.waters.push({ points, name: tags.name || '' });
          if (tags.name) {
            renderData.labels.push({
              name: tags.name,
              position: getCentroid(points),
              priority: 2
            });
          }
          continue;
        }

        if (tags.leisure === 'park' || tags.landuse === 'grass' || tags.landuse === 'meadow' || tags.landuse === 'forest') {
          renderData.areas.push({ points, type: tags.leisure || tags.landuse || '', name: tags.name || '' });
          if (tags.name) {
            renderData.labels.push({
              name: tags.name,
              position: getCentroid(points),
              priority: 1
            });
          }
        }
      }
    }

    function fitToView() {
      const viewportWidth = canvas.width / devicePixelRatio;
      const viewportHeight = canvas.height / devicePixelRatio;
      const padding = 24;
      const scaleX = (viewportWidth - padding * 2) / mapWidth;
      const scaleY = (viewportHeight - padding * 2) / mapHeight;
      let nextScale = clampScale(Math.min(scaleX, scaleY));
      if (!Number.isFinite(nextScale) || nextScale <= 0) {
        nextScale = 1;
      }
      state.scale = nextScale;
      state.minScale = nextScale * 0.6;
      state.maxScale = nextScale * 6;
      state.offsetX = (viewportWidth - mapWidth * nextScale) / 2;
      state.offsetY = (viewportHeight - mapHeight * nextScale) / 2;
    }

    function drawPath(points, closePath = false) {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      if (closePath) {
        ctx.closePath();
      }
    }

    function drawAreas() {
      const theme = THEMES[currentTheme];
      ctx.fillStyle = theme.park;
      for (const area of renderData.areas) {
        drawPath(area.points, true);
        ctx.fill();
      }
    }

    function drawWaters() {
      const theme = THEMES[currentTheme];
      ctx.fillStyle = theme.water;
      for (const water of renderData.waters) {
        drawPath(water.points, true);
        ctx.fill();
      }
    }

    function drawPitches() {
      const theme = THEMES[currentTheme];
      ctx.fillStyle = theme.pitchFill;
      ctx.strokeStyle = theme.pitchAccent;
      ctx.lineWidth = 6 / state.scale;
      for (const pitch of renderData.pitches) {
        drawPath(pitch.points, true);
        ctx.fill();
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.85)';
        ctx.lineWidth = 2 / state.scale;
        ctx.stroke();

        ctx.strokeStyle = theme.pitchAccent;
        ctx.lineWidth = 3.5 / state.scale;
        ctx.stroke();
      }
    }

    function drawBuildings() {
      const theme = THEMES[currentTheme];
      ctx.fillStyle = theme.buildingFill;
      ctx.strokeStyle = theme.buildingStroke;
      ctx.lineWidth = 1 / state.scale;
      for (const building of renderData.buildings) {
        drawPath(building.points, true);
        ctx.fill();
        ctx.stroke();
      }
    }

    function drawRoads() {
      const theme = THEMES[currentTheme];
      const roadStyles = theme.road;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      for (const road of renderData.roads) {
        const style = roadStyles[road.type] || { width: 2.2, color: '#ffffff', casing: '#d3dbe4' };
        ctx.strokeStyle = style.casing;
        ctx.lineWidth = (style.width + 1.6) / state.scale;
        drawPath(road.points, false);
        ctx.stroke();

        ctx.strokeStyle = style.color;
        ctx.lineWidth = style.width / state.scale;
        drawPath(road.points, false);
        ctx.stroke();
      }
    }

    function drawRoute() {
      if (!routePolyline.length || routePolyline.length < 2) {
        return;
      }
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = 'rgba(59, 130, 246, 0.75)';
      ctx.lineWidth = 10 / state.scale;
      drawPath(routePolyline, false);
      ctx.stroke();

      ctx.strokeStyle = '#1d4ed8';
      ctx.lineWidth = 6 / state.scale;
      drawPath(routePolyline, false);
      ctx.stroke();

      ctx.strokeStyle = '#93c5fd';
      ctx.lineWidth = 2.5 / state.scale;
      drawPath(routePolyline, false);
      ctx.stroke();
    }

    function drawLabels() {
      if (!showAutoLabels || state.scale < 0.7) {
        return;
      }
  const theme = THEMES[currentTheme];
  const fontSize = Math.max(11, 13 / state.scale);
  ctx.font = `${fontSize}px "PingFang SC", "HarmonyOS Sans", "Microsoft YaHei", sans-serif`;
  ctx.fillStyle = theme.label;
  ctx.strokeStyle = theme.labelHalo;
  ctx.lineWidth = 3 / state.scale;
      const gridSize = 90 / state.scale;
      const occupied = new Set();
      const sortedLabels = [...renderData.labels].sort((a, b) => (b.priority || 0) - (a.priority || 0));
      for (const label of sortedLabels) {
        const textX = label.position.x + 6 / state.scale;
        const textY = label.position.y - 6 / state.scale;
        const gridX = Math.floor(textX / gridSize);
        const gridY = Math.floor(textY / gridSize);
        const key = `${gridX}-${gridY}`;
        if (occupied.has(key)) {
          continue;
        }
        occupied.add(key);
        if ((label.priority || 0) >= 3) {
          const markerX = label.position.x;
          const markerY = label.position.y;
          const radius = 5 / state.scale;
          ctx.fillStyle = theme.poi;
          ctx.strokeStyle = theme.labelHalo;
          ctx.lineWidth = 2 / state.scale;
          ctx.beginPath();
          ctx.arc(markerX, markerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = theme.label;
          ctx.strokeStyle = theme.labelHalo;
          ctx.lineWidth = 3 / state.scale;
        }
        ctx.strokeText(label.name, textX, textY);
        ctx.fillText(label.name, textX, textY);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.setTransform(state.scale, 0, 0, state.scale, state.offsetX, state.offsetY);
  const theme = THEMES[currentTheme];
  ctx.fillStyle = theme.mapBase;
      ctx.fillRect(0, 0, mapWidth, mapHeight);
      if (dataReady) {
        drawAreas();
        drawWaters();
        drawPitches();
        drawBuildings();
        drawRoads();
        drawRoute();
        drawLabels();
        drawCustomMarkers();
      } else {
        ctx.fillStyle = theme.poi;
        ctx.font = `bold ${28 / state.scale}px "PingFang SC", "HarmonyOS Sans", "Microsoft YaHei", sans-serif`;
        const message = loadError ? 'OSM 加载失败' : '正在加载 OSM 数据…';
        ctx.fillText(message, 40, 80);
      }
      ctx.restore();
    }

    function fetchWithXHR(url) {
      return new Promise((resolve, reject) => {
        const request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.onreadystatechange = () => {
          if (request.readyState !== 4) {
            return;
          }
          if (request.status >= 200 && request.status < 300) {
            resolve(request.responseText);
          } else {
            reject(new Error(`XHR ${request.status}`));
          }
        };
        request.onerror = () => reject(new Error('XHR failed'));
        request.send(null);
      });
    }

    async function fetchText(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Fetch ${response.status}`);
        }
        return await response.text();
      } catch (error) {
        return await fetchWithXHR(url);
      }
    }

    function loadOSMFromText(text, sourceLabel) {
      const xmlDoc = new DOMParser().parseFromString(text, 'text/xml');
      const bounds = parseBounds(xmlDoc);
      if (!bounds) {
        throw new Error('OSM bounds 解析失败');
      }
      renderData.bounds = bounds;
      computeMapSize(bounds);
      buildRenderData(xmlDoc);
      dataReady = true;
      fitToView();
      setBadge(sourceLabel || '本地 OSM 地图 · 支持双指缩放与拖动');
    }

    async function loadOSM() {
      try {
        setBadge('正在加载 OSM 数据…');
        let text = '';
        let lastError = null;
        for (const url of OSM_URLS) {
          try {
            text = await fetchText(url);
            if (text) {
              break;
            }
          } catch (error) {
            lastError = error;
          }
        }
        if (!text) {
          throw lastError || new Error('OSM 加载失败');
        }
        loadOSMFromText(text, '本地 OSM 地图 · 支持双指缩放与拖动');
      } catch (error) {
        loadError = error;
        const message = error && error.message ? error.message : '未知错误';
        setBadge(`OSM 加载失败 · ${message} · 等待注入`);
        if (window.__PENDING_OSM_TEXT) {
          window.setOSMText(window.__PENDING_OSM_TEXT);
        } else {
          setTimeout(() => {
            if (!dataReady && window.__PENDING_OSM_TEXT) {
              window.setOSMText(window.__PENDING_OSM_TEXT);
            }
          }, 300);
        }
      }
      draw();
    }

    window.setOSMText = (text) => {
      try {
        if (!text || typeof text !== 'string') {
          throw new Error('注入数据为空');
        }
        loadOSMFromText(text, 'OSM 数据已注入 · 支持双指缩放与拖动');
        loadError = null;
      } catch (error) {
        loadError = error;
        const message = error && error.message ? error.message : '未知错误';
        setBadge(`OSM 注入失败 · ${message}`);
      }
      draw();
    };

    if (window.__PENDING_OSM_TEXT) {
      window.setOSMText(window.__PENDING_OSM_TEXT);
    }

    function drawCustomMarkers() {
      if (!customMarkers.length) {
        return;
      }
      const theme = THEMES[currentTheme];
      ctx.fillStyle = theme.poi;
      ctx.strokeStyle = theme.labelHalo;
      ctx.lineWidth = 2 / state.scale;
      ctx.font = `${Math.max(10, 12 / state.scale)}px "PingFang SC", "HarmonyOS Sans", "Microsoft YaHei", sans-serif`;
      ctx.fillStyle = theme.poi;
      for (const marker of customMarkers) {
        const point = project(marker.lat, marker.lon);
        const radius = 6 / state.scale;
        ctx.beginPath();
        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        if (marker.label) {
          const textX = point.x + 10 / state.scale;
          const textY = point.y - 6 / state.scale;
          ctx.strokeText(marker.label, textX, textY);
          ctx.fillText(marker.label, textX, textY);
        }
      }
    }

    window.setCustomMarkers = (markers) => {
      if (!Array.isArray(markers)) {
        return;
      }
      customMarkers.length = 0;
      for (const marker of markers) {
        if (typeof marker?.lat === 'number' && typeof marker?.lon === 'number') {
          customMarkers.push({
            lat: marker.lat,
            lon: marker.lon,
            label: typeof marker.label === 'string' ? marker.label : ''
          });
        }
      }
      draw();
    };

    window.addCustomMarker = (marker) => {
      if (marker && typeof marker.lat === 'number' && typeof marker.lon === 'number') {
        customMarkers.push({
          lat: marker.lat,
          lon: marker.lon,
          label: typeof marker.label === 'string' ? marker.label : ''
        });
        draw();
      }
    };

    window.setAutoLabelsEnabled = (enabled) => {
      showAutoLabels = Boolean(enabled);
      draw();
    };

    function findNearestNode(lat, lon) {
      let bestId = null;
      let bestDist = Number.POSITIVE_INFINITY;
      for (const [id, node] of graph.nodes.entries()) {
        const edges = graph.adj.get(id);
        if (!edges || edges.length === 0) {
          continue;
        }
        if (!Number.isFinite(node.lat) || !Number.isFinite(node.lon)) {
          continue;
        }
        const dist = distanceMeters(lat, lon, node.lat, node.lon);
        if (dist < bestDist) {
          bestDist = dist;
          bestId = id;
        }
      }
      return { id: bestId, dist: bestDist };
    }

    // 简易二叉堆实现的最小优先队列，用于 Dijkstra
    class MinHeap {
      constructor() {
        this.items = [];
      }

      push(item) {
        this.items.push(item);
        this.up(this.items.length - 1);
      }

      pop() {
        if (!this.items.length) {
          return null;
        }
        const root = this.items[0];
        const last = this.items.pop();
        if (this.items.length && last) {
          this.items[0] = last;
          this.down(0);
        }
        return root;
      }

      up(idx) {
        while (idx > 0) {
          const parent = (idx - 1) >> 1;
          if (this.items[parent].d <= this.items[idx].d) {
            break;
          }
          this.swap(parent, idx);
          idx = parent;
        }
      }

      down(idx) {
        const n = this.items.length;
        while (true) {
          let smallest = idx;
          const left = (idx << 1) + 1;
          const right = (idx << 1) + 2;
          if (left < n && this.items[left].d < this.items[smallest].d) {
            smallest = left;
          }
          if (right < n && this.items[right].d < this.items[smallest].d) {
            smallest = right;
          }
          if (smallest === idx) {
            break;
          }
          this.swap(idx, smallest);
          idx = smallest;
        }
      }

      swap(a, b) {
        const tmp = this.items[a];
        this.items[a] = this.items[b];
        this.items[b] = tmp;
      }

      isEmpty() {
        return this.items.length === 0;
      }
    }

    function shortestPath(startId, endId) {
      const dist = new Map();
      const prev = new Map();
      const visited = new Set();
      dist.set(startId, 0);
      const heap = new MinHeap();
      heap.push({ id: startId, d: 0 });
      while (!heap.isEmpty()) {
        const current = heap.pop();
        if (!current) {
          continue;
        }
        if (visited.has(current.id)) {
          continue;
        }
        visited.add(current.id);
        if (current.id === endId) {
          break;
        }
        const edges = graph.adj.get(current.id) || [];
        for (const edge of edges) {
          const nd = current.d + edge.w;
          const old = dist.get(edge.to);
          if (nd < (old ?? Number.POSITIVE_INFINITY)) {
            dist.set(edge.to, nd);
            prev.set(edge.to, current.id);
            heap.push({ id: edge.to, d: nd });
          }
        }
      }
      if (!prev.has(endId) && startId !== endId) {
        return null;
      }
      const path = [];
      let cur = endId;
      path.push(cur);
      while (prev.has(cur)) {
        cur = prev.get(cur);
        path.push(cur);
      }
      return path.reverse();
    }

    function buildPolylineFromNodes(pathIds) {
      const line = [];
      for (const id of pathIds) {
        const node = graph.nodes.get(id);
        if (!node) continue;
        const pt = project(node.lat, node.lon);
        if (Number.isFinite(pt.x) && Number.isFinite(pt.y)) {
          line.push(pt);
        }
      }
      // 防止过长路径导致绘制异常，必要时做抽稀
      const maxPoints = 8000;
      if (line.length > maxPoints) {
        const step = Math.ceil(line.length / maxPoints);
        const sampled = [];
        for (let i = 0; i < line.length; i += step) {
          sampled.push(line[i]);
        }
        if (line.length % step !== 0) {
          sampled.push(line[line.length - 1]);
        }
        return sampled;
      }
      return line;
    }

    function calcRouteDistance(pathIds) {
      let total = 0;
      for (let i = 1; i < pathIds.length; i++) {
        const a = graph.nodes.get(pathIds[i - 1]);
        const b = graph.nodes.get(pathIds[i]);
        if (a && b) {
          total += distanceMeters(a.lat, a.lon, b.lat, b.lon);
        }
      }
      return total;
    }

    function setRouteInternal(start, end) {
      if (!graph.nodes.size) {
        throw new Error('路网未构建');
      }
      const s = findNearestNode(start.lat, start.lon);
      const t = findNearestNode(end.lat, end.lon);
      if (!s.id || !t.id) {
        throw new Error('未找到可用节点');
      }
      const pathIds = shortestPath(s.id, t.id);
      if (!pathIds || pathIds.length < 2) {
        throw new Error('未找到可达路线');
      }
      routePolyline = buildPolylineFromNodes(pathIds);
      if (!routePolyline.length || routePolyline.length < 2) {
        throw new Error('路线绘制失败');
      }
      const distance = calcRouteDistance(pathIds);
      const speed = 1.4; // m/s walking speed
      const eta = distance / speed;
      routeInfo = { distance, eta, startNode: s.id, endNode: t.id };
      setBadge(`路线 ${Math.round(distance)} 米 · 约 ${Math.round(eta / 60)} 分钟`);
      draw();
    }

    window.setRoute = (payload) => {
      try {
        const start = payload?.start;
        const end = payload?.end;
        if (!start || !end || typeof start.lat !== 'number' || typeof start.lon !== 'number' || typeof end.lat !== 'number' || typeof end.lon !== 'number') {
          throw new Error('起终点坐标无效');
        }
        setRouteInternal(start, end);
        return { ok: true, info: routeInfo };
      } catch (error) {
        routePolyline = [];
        routeInfo = null;
        const message = error && error.message ? error.message : '未知错误';
        setBadge(`导航失败 · ${message}`);
        draw();
        return { ok: false, error: message };
      }
    };

    window.clearRoute = () => {
      routePolyline = [];
      routeInfo = null;
      setBadge('自定义地图 · 支持拖动与双指缩放');
      draw();
    };

    window.onerror = (message) => {
      try {
        setBadge(`导航失败 · ${String(message)}`);
      } catch (err) {
        // ignore
      }
      return false;
    };

    function onPointerDown(x, y) {
      state.dragging = true;
      state.lastX = x;
      state.lastY = y;
    }

    function onPointerMove(x, y) {
      if (!state.dragging) return;
      const dx = x - state.lastX;
      const dy = y - state.lastY;
      state.offsetX += dx;
      state.offsetY += dy;
      state.lastX = x;
      state.lastY = y;
      draw();
    }

    function onPointerUp() {
      state.dragging = false;
    }

    canvas.addEventListener('mousedown', (event) => {
      onPointerDown(event.clientX, event.clientY);
    });

    canvas.addEventListener('mousemove', (event) => {
      onPointerMove(event.clientX, event.clientY);
    });

    window.addEventListener('mouseup', () => {
      onPointerUp();
    });

    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      const delta = event.deltaY > 0 ? -0.1 : 0.1;
      zoomAt(event.clientX, event.clientY, state.scale + delta);
      draw();
    }, { passive: false });

    canvas.addEventListener('touchstart', (event) => {
      if (event.touches.length === 1) {
        const touch = event.touches[0];
        onPointerDown(touch.clientX, touch.clientY);
      } else if (event.touches.length === 2) {
        const [t1, t2] = event.touches;
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        state.pinchStartDist = Math.hypot(dx, dy);
        state.pinchStartScale = state.scale;
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (event) => {
      event.preventDefault();
      if (event.touches.length === 1) {
        const touch = event.touches[0];
        onPointerMove(touch.clientX, touch.clientY);
      } else if (event.touches.length === 2) {
        const [t1, t2] = event.touches;
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        const dist = Math.hypot(dx, dy);
        const midpointX = (t1.clientX + t2.clientX) / 2;
        const midpointY = (t1.clientY + t2.clientY) / 2;
        const nextScale = state.pinchStartScale * (dist / state.pinchStartDist);
        zoomAt(midpointX, midpointY, nextScale);
        draw();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      onPointerUp();
    });

    if (zoomInButton) {
      zoomInButton.addEventListener('click', () => {
        zoomAt(window.innerWidth / 2, window.innerHeight / 2, state.scale + 0.2);
        draw();
      });
    }

    if (zoomOutButton) {
      zoomOutButton.addEventListener('click', () => {
        zoomAt(window.innerWidth / 2, window.innerHeight / 2, state.scale - 0.2);
        draw();
      });
    }

    if (themeToggle) {
      themeToggle.addEventListener('click', () => {
        const nextTheme = currentTheme === 'day' ? 'night' : 'day';
        setTheme(nextTheme);
      });
    }

    window.addEventListener('resize', resize);

    resize();
  setTheme(currentTheme);
    loadOSM();
  </script>
</body>
</html>
